                return
                result.append(sol[:])
            if i == n: # outof bound we get the base case
        def backtrack(i):

        result , sol = [], []
        n = len(nums)

        #backtrack(i+1) once we use i, sol.pop() undo our decision before going back to next
        #the next element hence i+1 thus skipping, else we use it and append sol.nums[i], 
        #recursive backtrack, start at 0 ,if i== n we are goin to app the sol set to results, if not we backtrack/
    def subsets(self, nums: List[int]) -> List[List[int]]:
class Solution: